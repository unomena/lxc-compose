{% extends "base.html" %}

{% block title %}Shell - {{ container_name }} - LXC Compose Manager{% endblock %}

{% block extra_css %}
<style>
    #terminal {
        background: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
        font-size: 14px;
        padding: 10px;
        height: 600px;
        overflow-y: auto;
        border-radius: 5px;
        white-space: pre-wrap;
        word-wrap: break-word;
        cursor: text;
        position: relative;
    }
    
    #terminal:focus {
        outline: none;
        border: 1px solid #444;
    }
    
    .cursor {
        display: inline-block;
        width: 8px;
        height: 16px;
        background: #d4d4d4;
        animation: blink 1s infinite;
        vertical-align: text-bottom;
        margin-left: 2px;
    }
    
    @keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0; }
    }
    
    .terminal-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 15px;
        border-radius: 5px 5px 0 0;
        margin-bottom: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .terminal-title {
        font-size: 18px;
        font-weight: 500;
    }
    
    .terminal-info {
        font-size: 14px;
        opacity: 0.9;
    }
    
    .terminal-line {
        margin: 2px 0;
        line-height: 1.4;
    }
    
    .terminal-prompt {
        color: #4fc3f7;
        font-weight: bold;
    }
    
    .terminal-output {
        color: #d4d4d4;
    }
    
    .terminal-error {
        color: #f44336;
    }
    
    .terminal-success {
        color: #4caf50;
    }
    
    .connection-status {
        padding: 5px 10px;
        border-radius: 3px;
        font-size: 12px;
        font-weight: 500;
    }
    
    .status-connected {
        background: #4caf50;
        color: white;
    }
    
    .status-disconnected {
        background: #f44336;
        color: white;
    }
    
    .status-connecting {
        background: #ff9800;
        color: white;
    }
    
    .input-line {
        display: inline;
    }
</style>
{% endblock %}

{% block content %}
<div class="terminal-header">
    <div>
        <div class="terminal-title">Container Shell: {{ container_name }}</div>
        <div class="terminal-info">Interactive shell session</div>
    </div>
    <div>
        <span id="connectionStatus" class="connection-status status-disconnected">Disconnected</span>
    </div>
</div>

<div id="terminal" tabindex="0"></div>

<div style="margin-top: 15px;">
    <button id="clearBtn" class="btn btn-secondary">Clear</button>
    <button id="closeBtn" class="btn btn-secondary">Close</button>
    <button id="reconnectBtn" class="btn btn-primary">Reconnect</button>
</div>
{% endblock %}

{% block extra_js %}
<script>
    console.log('Shell.html script loaded - Version 4 - Tab completion and Ctrl+D support');
    const containerName = '{{ container_name }}';
    const sessionId = '{{ session_id }}';
    let currentWorkingDir = '/root';
    let currentCommand = '';
    let commandHistory = [];
    let historyIndex = -1;
    let terminal = null;
    let connectionStatus = null;
    
    function updateConnectionStatus(status) {
        if (!connectionStatus) return;
        connectionStatus.className = 'connection-status';
        switch(status) {
            case 'connected':
                connectionStatus.textContent = 'Connected';
                connectionStatus.classList.add('status-connected');
                break;
            case 'disconnected':
                connectionStatus.textContent = 'Disconnected';
                connectionStatus.classList.add('status-disconnected');
                break;
            case 'connecting':
                connectionStatus.textContent = 'Connecting...';
                connectionStatus.classList.add('status-connecting');
                break;
        }
    }
    
    function getPrompt() {
        const shortPath = currentWorkingDir.replace('/root', '~');
        return `root@${containerName}:${shortPath}# `;
    }
    
    function appendOutput(text, className = 'terminal-output') {
        if (!terminal) return;
        
        // Remove the input line temporarily
        const inputLine = terminal.querySelector('.input-line');
        if (inputLine) inputLine.remove();
        
        // Add the output
        const line = document.createElement('div');
        line.className = `terminal-line ${className}`;
        line.textContent = text;
        terminal.appendChild(line);
        
        // Restore the input line
        showInputLine();
        terminal.scrollTop = terminal.scrollHeight;
    }
    
    function showInputLine() {
        if (!terminal) return;
        
        // Remove any existing input line
        const existingInputLine = terminal.querySelector('.input-line');
        if (existingInputLine) {
            existingInputLine.remove();
        }
        
        // Create new input line
        const inputLine = document.createElement('div');
        inputLine.className = 'terminal-line input-line';
        
        const prompt = document.createElement('span');
        prompt.className = 'terminal-prompt';
        prompt.textContent = getPrompt();
        
        const commandSpan = document.createElement('span');
        commandSpan.textContent = currentCommand;
        
        const cursor = document.createElement('span');
        cursor.className = 'cursor';
        
        inputLine.appendChild(prompt);
        inputLine.appendChild(commandSpan);
        inputLine.appendChild(cursor);
        
        terminal.appendChild(inputLine);
        terminal.scrollTop = terminal.scrollHeight;
    }
    
    function executeCommand(command) {
        if (!terminal) return;
        
        // Remove input line and show command being executed
        const inputLine = terminal.querySelector('.input-line');
        if (inputLine) inputLine.remove();
        
        // Show the executed command
        const cmdLine = document.createElement('div');
        cmdLine.className = 'terminal-line';
        const prompt = document.createElement('span');
        prompt.className = 'terminal-prompt';
        prompt.textContent = getPrompt();
        cmdLine.appendChild(prompt);
        cmdLine.appendChild(document.createTextNode(command));
        terminal.appendChild(cmdLine);
        
        // Check for interactive commands
        const interactiveCommands = ['top', 'htop', 'less', 'more', 'vi', 'vim', 'nano', 'emacs', 'tail -f', 'watch'];
        const isInteractive = interactiveCommands.some(cmd => command.startsWith(cmd));
        
        if (isInteractive) {
            const cmdName = command.split(' ')[0];
            appendOutput(`❌ '${cmdName}' is an interactive command and won't work in this restricted shell.`, 'terminal-error');
            
            if (command.startsWith('top') || command.startsWith('htop')) {
                appendOutput(`💡 Use: ps aux --sort=-%cpu`, 'terminal-success');
            } else if (command.startsWith('tail -f')) {
                const file = command.split(' ')[2] || '<file>';
                appendOutput(`💡 Use: tail -n 20 ${file}`, 'terminal-success');
            } else if (command.startsWith('less') || command.startsWith('more')) {
                const file = command.split(' ')[1] || '<file>';
                appendOutput(`💡 Use: cat ${file} | head -50`, 'terminal-success');
            } else if (command.startsWith('vi') || command.startsWith('vim') || command.startsWith('nano')) {
                appendOutput(`💡 Edit files locally or use: cat > file.txt << EOF`, 'terminal-success');
            }
            
            currentCommand = '';
            showInputLine();
            return;
        }
        
        // Execute command via API
        fetch('/api/command/execute', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                command: `execute ${containerName} ${command}`,
                session_id: sessionId
            })
        })
        .then(response => response.json())
        .then(data => {
            // Update working directory if it changed
            if (data.working_dir) {
                currentWorkingDir = data.working_dir;
            }
            
            if (data.success) {
                if (data.stdout) {
                    appendOutput(data.stdout);
                }
                if (data.stderr && data.stderr.trim()) {
                    appendOutput(data.stderr, 'terminal-error');
                }
            } else if (data.error) {
                appendOutput(`Error: ${data.error}`, 'terminal-error');
            } else if (data.stdout || data.stderr) {
                if (data.stdout) {
                    appendOutput(data.stdout);
                }
                if (data.stderr) {
                    appendOutput(data.stderr, 'terminal-error');
                }
            }
            
            currentCommand = '';
            showInputLine();
        })
        .catch(error => {
            appendOutput(`Error: ${error.message}`, 'terminal-error');
            currentCommand = '';
            showInputLine();
        });
    }
    
    function connectShell() {
        if (!terminal) {
            console.error('Cannot connect: terminal not initialized');
            return;
        }
        
        updateConnectionStatus('connecting');
        
        terminal.innerHTML = '';
        
        // Immediately set as connected
        updateConnectionStatus('connected');
        
        // Show welcome message
        appendOutput('═══════════════════════════════════════════════════════════════', 'terminal-output');
        appendOutput('                    Web Shell - Restricted Mode', 'terminal-success');
        appendOutput('═══════════════════════════════════════════════════════════════', 'terminal-output');
        appendOutput('', 'terminal-output');
        appendOutput('⚠️  This is a restricted, non-interactive shell with limitations:', 'terminal-output');
        appendOutput('', 'terminal-output');
        appendOutput('❌ Interactive commands will NOT work:', 'terminal-error');
        appendOutput('   • top, htop (use: ps aux)', 'terminal-output');
        appendOutput('   • vi, vim, nano (edit files locally instead)', 'terminal-output');
        appendOutput('   • less, more (use: cat or head/tail)', 'terminal-output');
        appendOutput('   • tail -f (use: tail -n 20)', 'terminal-output');
        appendOutput('   • Interactive installers', 'terminal-output');
        appendOutput('', 'terminal-output');
        appendOutput('✅ Commands that WILL work:', 'terminal-success');
        appendOutput('   • Navigation: ls, cd, pwd', 'terminal-output');
        appendOutput('   • File viewing: cat, head, tail, grep', 'terminal-output');
        appendOutput('   • Process info: ps, ps aux, kill', 'terminal-output');
        appendOutput('   • Network: ping, curl, wget', 'terminal-output');
        appendOutput('   • Package management: apt update, apt install -y', 'terminal-output');
        appendOutput('   • Most other non-interactive commands', 'terminal-output');
        appendOutput('', 'terminal-output');
        appendOutput('💡 For full shell access, SSH to the host and use:', 'terminal-output');
        appendOutput(`   sudo lxc-attach -n ${containerName}`, 'terminal-output');
        appendOutput('', 'terminal-output');
        appendOutput('═══════════════════════════════════════════════════════════════', 'terminal-output');
        appendOutput('', 'terminal-output');
        
        currentCommand = '';
        showInputLine();
    }
    
    function clearTerminal() {
        if (!terminal) return;
        
        terminal.innerHTML = '';
        appendOutput(`Terminal cleared`, 'terminal-success');
        currentCommand = '';
        showInputLine();
    }
    
    // Handle tab completion
    function handleTabCompletion() {
        if (!currentCommand) return;
        
        const parts = currentCommand.split(' ');
        const lastPart = parts[parts.length - 1];
        
        // Determine context - command or path
        const context = parts.length === 1 ? 'command' : 'path';
        
        // Use the autocomplete API
        fetch('/api/autocomplete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                container: containerName,
                partial: lastPart,
                context: context,
                session_id: sessionId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.suggestions && data.suggestions.length > 0) {
                if (data.suggestions.length === 1) {
                    // Single match - complete it
                    if (context === 'command') {
                        currentCommand = data.suggestions[0] + ' ';
                    } else {
                        parts[parts.length - 1] = data.suggestions[0];
                        currentCommand = parts.join(' ');
                    }
                    showInputLine();
                } else {
                    // Multiple matches - show them
                    const displayItems = data.suggestions.map(s => {
                        // For paths, show just the last part for readability
                        if (context === 'path' && s.includes('/')) {
                            const basename = s.split('/').pop() || s;
                            return s.endsWith('/') ? basename + '/' : basename;
                        }
                        return s;
                    });
                    
                    appendOutput('', 'terminal-output');
                    appendOutput(displayItems.join('  '), 'terminal-output');
                    
                    // Find common prefix and complete to that
                    const commonPrefix = findCommonPrefix(data.suggestions);
                    if (commonPrefix && commonPrefix.length > lastPart.length) {
                        if (context === 'command') {
                            currentCommand = commonPrefix;
                        } else {
                            parts[parts.length - 1] = commonPrefix;
                            currentCommand = parts.join(' ');
                        }
                    }
                    showInputLine();
                }
            }
        })
        .catch(error => {
            console.error('Autocomplete error:', error);
        });
    }
    
    // Helper function to find common prefix among strings
    function findCommonPrefix(strings) {
        if (!strings || strings.length === 0) return '';
        if (strings.length === 1) return strings[0];
        
        let prefix = strings[0];
        for (let i = 1; i < strings.length; i++) {
            while (!strings[i].startsWith(prefix)) {
                prefix = prefix.substring(0, prefix.length - 1);
                if (prefix === '') return '';
            }
        }
        return prefix;
    }
    
    // Handle keyboard input (will be set up after DOM loads)
    function setupKeyboardHandler() {
        if (!terminal) return;
        
        terminal.addEventListener('keydown', (e) => {
            e.preventDefault();
            
            if (e.key === 'Enter') {
                if (currentCommand.trim()) {
                    commandHistory.push(currentCommand);
                    historyIndex = commandHistory.length;
                    executeCommand(currentCommand);
                }
            } else if (e.key === 'Backspace') {
                if (currentCommand.length > 0) {
                    currentCommand = currentCommand.slice(0, -1);
                    showInputLine();
                }
            } else if (e.key === 'ArrowUp') {
                if (historyIndex > 0) {
                    historyIndex--;
                    currentCommand = commandHistory[historyIndex];
                    showInputLine();
                }
            } else if (e.key === 'ArrowDown') {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    currentCommand = commandHistory[historyIndex];
                    showInputLine();
                } else if (historyIndex === commandHistory.length - 1) {
                    historyIndex = commandHistory.length;
                    currentCommand = '';
                    showInputLine();
                }
            } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                currentCommand += e.key;
                showInputLine();
            } else if (e.ctrlKey && e.key === 'c') {
                currentCommand = '';
                appendOutput('^C', 'terminal-output');
                showInputLine();
            } else if (e.ctrlKey && e.key === 'l') {
                clearTerminal();
            } else if (e.ctrlKey && e.key === 'd') {
                // Ctrl+D - same as clicking Close button
                window.close();
            } else if (e.key === 'Tab') {
                // Tab completion
                handleTabCompletion();
            }
        });
    }
    
    // Focus terminal on click (will be set up after DOM loads)
    function setupClickHandler() {
        if (!terminal) return;
        
        terminal.addEventListener('click', () => {
            terminal.focus();
        });
    }
    
    // Connect on load
    window.addEventListener('load', () => {
        // Initialize DOM elements
        terminal = document.getElementById('terminal');
        connectionStatus = document.getElementById('connectionStatus');
        
        if (!terminal || !connectionStatus) {
            console.error('Terminal elements not found in DOM');
            return;
        }
        
        // Set up button event handlers
        const clearBtn = document.getElementById('clearBtn');
        const closeBtn = document.getElementById('closeBtn');
        const reconnectBtn = document.getElementById('reconnectBtn');
        
        if (clearBtn) {
            clearBtn.addEventListener('click', () => clearTerminal());
        }
        if (closeBtn) {
            closeBtn.addEventListener('click', () => window.close());
        }
        if (reconnectBtn) {
            reconnectBtn.addEventListener('click', () => connectShell());
        }
        
        // Set up keyboard and click handlers
        setupKeyboardHandler();
        setupClickHandler();
        
        // Connect to shell
        setTimeout(() => {
            connectShell();
            terminal.focus();
        }, 100);
    });
</script>
{% endblock %}